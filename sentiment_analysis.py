import numpy as np
import pandas as pd
from tqdm.auto import tqdm

def encode_reviews(tokenizer, reviews, max_length):
    
    """
    Function that encodes and format the text of the review so that it can be
    read by CamemBERT
    PARAMETERS:
        tokenizer => the base tokenizer provided by CamemBERT
        reviews : np.array => the array containing the text of all the reviews
            that we want to anaylse
        max_length : int => the maximum number of tokens generated by the tokenizer
            (the model only accepts a maximum of 512 inputs)
    """

    token_ids = np.zeros(shape=(len(reviews), max_length),
                        dtype=np.int32)
    for i, review in enumerate(reviews):
        encoded = tokenizer.encode(review, truncation = True, max_length=max_length)
        # print(len(encoded))
        token_ids[i, 0:len(encoded)] = encoded
    attention_mask = (token_ids != 0).astype(np.int32)
    return {"input_ids": token_ids, "attention_mask": attention_mask}

def reworked_pipeline(review : str, tokenizer, model):
    
    """
    Function that returns the prediction of the sentiment of the review.
    PARAMETERS:
        review : str => The review to analyse
        tokenizer => the base tokenizer provided by CamemBERT
        model => the CamemBERT model used to predict the sentiment
    RETURNS:
        result : dict => the result of the analysis by the CamemBERT model
    """
    
    # encode the review
    review_encoded = encode_reviews(tokenizer, np.array([review]), 512)
    
    # predict
    prediction_output = model.predict(review_encoded)

    # analyse the prediction

    ## get the index of the highest logit
    prediction = np.argmax(prediction_output["logits"][0])

    ## get the probability associated
    probability = 1 / (1 + np.exp(-prediction_output["logits"][0][prediction]))
    
    # return the result
    result = {
        "label": "POSITIVE" if prediction == 1 else "NEGATIVE",
        "probability": probability
    }
    return result

def analyse_reviews(df_reviews : pd.DataFrame, tokenizer, model):
    
    """
    Function that adds the predicted label and the associated probability to each
    reviews in df_reviews.
    PARAMETERS:
        df_reviews : pd.DataFrame => the dataframe containing all the reviews that need
            to be analysed.
    RETURNS:
        df_reviews_analysed : pd.DataFrame => the new dataframe containing all the
            predicted labels.
    """

    # create a dictionary that will hold the labels and the probabilities
    prediction_dict = {
        "predicted_sentiment": [],
        "prediction_probability": []
    }

    # analyse every review in df_reviews and store the results in prediction_dict
    for review in tqdm(df_reviews["review"]):
        prediction = reworked_pipeline(review, tokenizer, model)
        prediction_dict["predicted_sentiment"].append(prediction["label"])
        prediction_dict["prediction_probability"].append(prediction["probability"])
    
    # make a DataFrame out of the dictionnary
    df_predictions = pd.DataFrame.from_dict(prediction_dict)

    # concat df_review with df_predictions and return the result
    return pd.concat([df_reviews, df_predictions], axis=1)